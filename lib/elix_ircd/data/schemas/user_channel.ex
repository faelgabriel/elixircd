defmodule ElixIRCd.Data.Schemas.UserChannel do
  @moduledoc """
  Module for the UserChannel schema.
  """

  alias Ecto.Changeset
  alias ElixIRCd.Data.Schemas.Channel
  alias ElixIRCd.Data.Schemas.User
  alias ElixIRCd.Data.Schemas.UserChannel
  alias ElixIRCd.Types.PortType

  import Ecto.Changeset

  use TypedEctoSchema

  @modes [
    # Admin or Protected (&)
    :admin,
    # Channel operator (@)
    :operator,
    # Half operator (%)
    :half_operator,
    # Channel voice (+)
    :voice
  ]

  # ETSO adapter does not support composite primary keys to be used with user and channel,
  # so temporarily it is using a autogenerated id. It needs to be improved in the future.
  @primary_key {:id, :binary_id, autogenerate: true}
  typed_schema "user_channel" do
    belongs_to(:user, User, references: :socket, type: PortType, foreign_key: :user_socket)
    belongs_to(:channel, Channel, references: :name, type: :string, foreign_key: :channel_name)

    field(:modes, {:array, :any}, default: [])
  end

  @doc """
  Creates a changeset for a UserChannel.
  """
  @spec changeset(UserChannel.t(), map()) :: Changeset.t()
  def changeset(user_channel, attrs) do
    user_channel
    |> cast(attrs, [:user_socket, :channel_name, :modes])
    |> validate_required([:user_socket, :channel_name])
    |> validate_modes()
  end

  @spec validate_modes(Changeset.t()) :: Changeset.t()
  defp validate_modes(changeset) do
    modes = get_field(changeset, :modes, [])

    if Enum.all?(modes, fn {mode, _} -> Enum.member?(@modes, mode) end) do
      changeset
    else
      add_error(changeset, :modes, "Invalid user channel modes: #{inspect(modes)}")
    end
  end
end
